#!/bin/bash
# Vulnerability Detection Module
# Identifies common vulnerabilities and security misconfigurations

set -uo pipefail

VULN_OUTPUT=""
CRITICAL_COUNT=0
HIGH_COUNT=0
MEDIUM_COUNT=0
LOW_COUNT=0

log_vuln() {
    VULN_OUTPUT+="$1\n"
}

add_finding() {
    local severity=$1
    local title=$2
    local description=$3
    local remediation=$4

    case $severity in
        CRITICAL)
            CRITICAL_COUNT=$((CRITICAL_COUNT + 1))
            COLOR="#dc3545"
            ;;
        HIGH)
            HIGH_COUNT=$((HIGH_COUNT + 1))
            COLOR="#fd7e14"
            ;;
        MEDIUM)
            MEDIUM_COUNT=$((MEDIUM_COUNT + 1))
            COLOR="#ffc107"
            ;;
        LOW)
            LOW_COUNT=$((LOW_COUNT + 1))
            COLOR="#17a2b8"
            ;;
    esac

    log_vuln "<div style='border-left: 4px solid $COLOR; padding-left: 10px; margin: 10px 0;'>"
    log_vuln "<h4 style='color: $COLOR;'>[$severity] $title</h4>"
    log_vuln "<p><strong>Description:</strong> $description</p>"
    log_vuln "<p><strong>Remediation:</strong> $remediation</p>"
    log_vuln "</div>"
}

vulnerability_scan_module() {
    log_vuln "<h2>Vulnerability Assessment</h2>"

    # SSL/TLS Certificate Check
    log_vuln "<h3>SSL/TLS Certificate Validation</h3>"

    HTTPS_SERVICES=$(ss -tlnp 2>/dev/null | grep ":443" | wc -l)
    if [ $HTTPS_SERVICES -gt 0 ]; then
        log_vuln "<p>Found $HTTPS_SERVICES services on port 443</p>"

        # Check localhost SSL certificate
        if timeout 5 openssl s_client -connect localhost:443 -servername localhost </dev/null 2>/dev/null | grep -q "Verify return code"; then
            CERT_INFO=$(timeout 5 openssl s_client -connect localhost:443 -servername localhost </dev/null 2>/dev/null)
            VERIFY_CODE=$(echo "$CERT_INFO" | grep "Verify return code" | cut -d: -f2-)

            if echo "$VERIFY_CODE" | grep -q "0 (ok)"; then
                log_vuln "<p style='color: green;'>Certificate verification: PASSED</p>"
            else
                add_finding "HIGH" "SSL Certificate Validation Failed" \
                    "SSL certificate on localhost:443 failed verification: $VERIFY_CODE" \
                    "Update SSL certificates with valid CA-signed certificates"
            fi

            # Check expiration
            EXPIRY=$(echo "$CERT_INFO" | openssl x509 -noout -enddate 2>/dev/null | cut -d= -f2)
            if [ -n "$EXPIRY" ]; then
                log_vuln "<p>Certificate expiry: $EXPIRY</p>"
            fi
        fi
    else
        log_vuln "<p>No HTTPS services detected on port 443</p>"
    fi

    # Check for weak SSH configuration
    log_vuln "<h3>SSH Security Assessment</h3>"

    if [ -f /etc/ssh/sshd_config ]; then
        # Check root login
        ROOT_LOGIN=$(grep "^PermitRootLogin" /etc/ssh/sshd_config | awk '{print $2}')
        if [ "$ROOT_LOGIN" == "yes" ]; then
            add_finding "CRITICAL" "SSH Root Login Enabled" \
                "SSH is configured to allow direct root login, which is a significant security risk" \
                "Edit /etc/ssh/sshd_config and set 'PermitRootLogin no', then restart SSH service"
        fi

        # Check password authentication
        PASS_AUTH=$(grep "^PasswordAuthentication" /etc/ssh/sshd_config | awk '{print $2}')
        if [ "$PASS_AUTH" == "yes" ]; then
            add_finding "MEDIUM" "SSH Password Authentication Enabled" \
                "SSH allows password authentication, which is vulnerable to brute-force attacks" \
                "Consider using key-based authentication only: Set 'PasswordAuthentication no' in /etc/ssh/sshd_config"
        fi

        # Check for default SSH port
        SSH_PORT=$(grep "^Port" /etc/ssh/sshd_config | awk '{print $2}')
        if [ -z "$SSH_PORT" ] || [ "$SSH_PORT" == "22" ]; then
            add_finding "LOW" "SSH Running on Default Port" \
                "SSH is running on the default port 22, making it an easy target for automated attacks" \
                "Consider changing SSH port to a non-standard port above 1024"
        fi
    fi

    # Check for unattended upgrades
    log_vuln "<h3>Automatic Security Updates</h3>"

    if [ -f /etc/apt/apt.conf.d/50unattended-upgrades ]; then
        if systemctl is-enabled unattended-upgrades &>/dev/null; then
            log_vuln "<p style='color: green;'>Unattended upgrades: ENABLED</p>"
        else
            add_finding "MEDIUM" "Automatic Security Updates Not Enabled" \
                "System is not configured for automatic security updates" \
                "Enable unattended-upgrades: sudo dpkg-reconfigure -plow unattended-upgrades"
        fi
    else
        add_finding "MEDIUM" "Unattended Upgrades Not Installed" \
            "Automatic security update system is not installed" \
            "Install unattended-upgrades: sudo apt install unattended-upgrades"
    fi

    # Check firewall status
    log_vuln "<h3>Firewall Configuration</h3>"

    if command -v ufw &> /dev/null; then
        UFW_ACTIVE=$(ufw status | grep -i "Status: active")
        if [ -z "$UFW_ACTIVE" ]; then
            add_finding "HIGH" "Firewall Disabled" \
                "UFW firewall is installed but not active" \
                "Enable UFW firewall: sudo ufw enable"
        else
            log_vuln "<p style='color: green;'>UFW firewall: ACTIVE</p>"
        fi
    else
        add_finding "MEDIUM" "No Firewall Detected" \
            "UFW firewall is not installed on the system" \
            "Install and configure UFW: sudo apt install ufw && sudo ufw enable"
    fi

    # Check for Docker socket exposure
    log_vuln "<h3>Container Security</h3>"

    if [ -S /var/run/docker.sock ]; then
        DOCKER_PERMS=$(ls -l /var/run/docker.sock 2>/dev/null)
        log_vuln "<p>Docker socket found: $DOCKER_PERMS</p>"

        # Check if docker socket is world-accessible
        if [ -w /var/run/docker.sock ]; then
            DOCKER_GROUP=$(ls -l /var/run/docker.sock | awk '{print $4}')
            if [ "$DOCKER_GROUP" != "docker" ]; then
                add_finding "HIGH" "Docker Socket Insecure Permissions" \
                    "Docker socket has insecure permissions allowing unauthorized access" \
                    "Restrict docker socket permissions: sudo chmod 660 /var/run/docker.sock"
            fi
        fi

        # Check for privileged containers
        if command -v docker &> /dev/null; then
            PRIV_CONTAINERS=$(docker ps --quiet 2>/dev/null | xargs docker inspect --format='{{.Name}} {{.HostConfig.Privileged}}' 2>/dev/null | grep true || true)
            if [ -n "$PRIV_CONTAINERS" ]; then
                add_finding "HIGH" "Privileged Docker Containers Running" \
                    "Privileged containers detected, which have full access to host system" \
                    "Avoid running containers in privileged mode unless absolutely necessary"
            fi
        fi
    fi

    # Check kernel version for known vulnerabilities
    log_vuln "<h3>Kernel Security</h3>"

    KERNEL_VERSION=$(uname -r)
    log_vuln "<p>Current kernel: $KERNEL_VERSION</p>"

    # Check if kernel is extremely outdated (older than 1 year is a rough heuristic)
    LATEST_KERNEL=$(ls -t /boot/vmlinuz-* 2>/dev/null | head -1 | sed 's/.*vmlinuz-//')
    if [ "$KERNEL_VERSION" != "$LATEST_KERNEL" ]; then
        add_finding "MEDIUM" "Outdated Kernel Running" \
            "System is not running the latest installed kernel ($KERNEL_VERSION vs $LATEST_KERNEL)" \
            "Reboot the system to load the latest kernel version"
    fi

    # Check for open database ports
    log_vuln "<h3>Database Exposure Check</h3>"

    DB_PORTS="3306 5432 27017 6379 9200"
    for port in $DB_PORTS; do
        if ss -tln 2>/dev/null | grep -q ":$port "; then
            LISTENING=$(ss -tln 2>/dev/null | grep ":$port " | grep -v "127.0.0.1")
            if [ -n "$LISTENING" ]; then
                DB_NAME="Unknown"
                case $port in
                    3306) DB_NAME="MySQL/MariaDB";;
                    5432) DB_NAME="PostgreSQL";;
                    27017) DB_NAME="MongoDB";;
                    6379) DB_NAME="Redis";;
                    9200) DB_NAME="Elasticsearch";;
                esac

                add_finding "CRITICAL" "$DB_NAME Exposed on Network" \
                    "Database service ($DB_NAME) is listening on port $port and exposed to network" \
                    "Bind database to localhost only or implement proper firewall rules"
            fi
        fi
    done

    # Summary
    log_vuln "<h3>Vulnerability Summary</h3>"
    log_vuln "<table border='1' cellpadding='10' style='border-collapse: collapse; width: 100%;'>"
    log_vuln "<tr style='background-color: #f8f9fa;'><th>Severity</th><th>Count</th></tr>"
    log_vuln "<tr><td style='color: #dc3545;'><strong>CRITICAL</strong></td><td>$CRITICAL_COUNT</td></tr>"
    log_vuln "<tr><td style='color: #fd7e14;'><strong>HIGH</strong></td><td>$HIGH_COUNT</td></tr>"
    log_vuln "<tr><td style='color: #ffc107;'><strong>MEDIUM</strong></td><td>$MEDIUM_COUNT</td></tr>"
    log_vuln "<tr><td style='color: #17a2b8;'><strong>LOW</strong></td><td>$LOW_COUNT</td></tr>"
    log_vuln "</table>"

    # Export counts for main script
    echo "CRITICAL=$CRITICAL_COUNT"
    echo "HIGH=$HIGH_COUNT"
    echo "MEDIUM=$MEDIUM_COUNT"
    echo "LOW=$LOW_COUNT"
    echo "$VULN_OUTPUT"
}

# If run directly, execute
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    vulnerability_scan_module
fi
